#include "utility.hpp"
#include "data_structures.hpp"
#include "data_io.hpp"
#include "d8_methods.hpp"
#include "dinf_methods.hpp"
#include "pit_fill.hpp"
#include "interface.hpp"
#include "flat_resolution.hpp"
#include "debug.hpp"
#include <string>
#include <sys/time.h>
#include <iostream>
using namespace std;

std::string make_fname(std::string base, const char str[], int do_fill, int do_d8){
    std::string temp;
    std::stringstream ss (std::stringstream::in | std::stringstream::out);
    ss<<base<<str<<"_"<<(do_fill?"fl":"nfl")<<"_"<<(do_d8?"d8":"dinf");
    temp=ss.str();
    return temp;
}

/**
    @brief  Calculates Jacob's Wetland Metric
    @author Richard Barnes (rbarnes@umn.edu), Jacob Galzki

    @param[in]    &smoothed_cti
        CTI generated with d8_CTI() and smoothed with array2d::low_pass_filter()
    @param[in]    &hydric_soils
        A grid containing a [0,2] representation of hydric soils. 0=no hydric soil presence, 1=partial presence, and 2=all hydric soils.
    @param[in]    &smoothed_percent_slope
        Percent Slope grid generated by d8_slope() with argument #TATTRIB_SLOPE_PERCENT and smoothed with array2d::low_pass_filter()
    @param[in]    &smoothed_profile_curvature
        Profile curvature grid generated by d8_profile_curvature() and smoothed with array2d::low_pass_filter()
    @param[out]   &result
        Hold's Jacob's Wetland Metric: a probability of a given cell being part of a wetland

    @pre All grids should be the same size

    @post \pname{result} takes the properties and dimensions of \pname{smoothed_cti}

    @todo Ensure all grids are the same size
*/

int main(int argc, char **argv){
    if(argc!=4){
      cerr<<"Syntax: "<<argv[0]<<" <Input DEM> <Hydric Soils> <Output Base Name>"<<endl;
      return -1;
    }

    std::string oname=argv[3];

    float_2d elevations;

    read_data(argv[1],elevations);
    elevations.low_pass_filter();

    for(int do_fill=0;do_fill<2;do_fill++){
        if(do_fill)
            barnes_flood(elevations);

        for(int do_d8=0;do_d8<2;do_d8++){
            float_2d area;

            {
              float_2d flowdirs(elevations);
              {
                int_2d flat_resolution_mask, groups;

                if(do_d8)
                    d8_flow_directions(elevations,flowdirs);
                else
                    dinf_flow_directions(elevations,flowdirs);

    //            write_floating_data(make_fname(oname,"_flowdirs",do_fill,do_d8), flowdirs);

                resolve_flats_barnes(elevations, flowdirs, flat_resolution_mask, groups);

                if(do_d8)
                    d8_flow_flats(flat_resolution_mask, groups, flowdirs);
                else
                    dinf_flow_flats(flat_resolution_mask,groups,flowdirs);

    //            output_ascii_data(make_fname(oname,"_flowdirs_nflats",do_fill,do_d8), flowdirs);

                flat_resolution_mask.clear();
                groups.clear();

                if(do_d8)
                    d8_upslope_area(flowdirs, area);
                else
                    dinf_upslope_area(flowdirs, area);
                flowdirs.clear();
              }
            }

            write_floating_data(make_fname(oname,"_area",do_fill,do_d8), area);

            float_2d linear_regressor(elevations);
            linear_regressor.init(-4);
            linear_regressor.no_data=-99999.123456;

            {
              float_2d percent_slope;
              d8_slope(elevations, percent_slope, TATTRIB_SLOPE_PERCENT);

              {
                float_2d spi;
                d8_SPI(area, percent_slope, spi);
                spi.low_pass_filter();
                write_floating_data(make_fname(oname,"_spi",do_fill,do_d8), spi);
                spi.clear();
              }

              {
                float_2d cti;
                d8_CTI(area, percent_slope, cti);
                area.clear();

                cti.low_pass_filter();
                write_floating_data(make_fname(oname,"_cti",do_fill,do_d8), cti);
                linear_regressor+=cti*0.5;
                cti.clear();
              }

              percent_slope.low_pass_filter();
              write_floating_data(make_fname(oname,"_slope",do_fill,do_d8), percent_slope);
              linear_regressor+=percent_slope*-0.2;
              percent_slope.clear();
            }

            {
              float_2d planform_curvature;
              d8_planform_curvature(elevations, planform_curvature);
              planform_curvature.low_pass_filter();
              write_floating_data(make_fname(oname,"_planform",do_fill,do_d8), planform_curvature);
              planform_curvature.clear();
            }

            {
              float_2d profile_curvature;
              d8_profile_curvature(elevations, profile_curvature);

              profile_curvature.low_pass_filter();
              write_floating_data(make_fname(oname,"_profile",do_fill,do_d8), profile_curvature);
              linear_regressor+=profile_curvature*-0.5;
              profile_curvature.clear();
            }

            {
              char_2d hydric_soils;
              read_data(argv[2], hydric_soils);

              linear_regressor+=hydric_soils;
              hydric_soils.clear();
            }

            diagnostic("Jacob's Wetland Metric...");
            #pragma omp parallel for collapse(2)
            for(int x=0;x<linear_regressor.width();x++)
            for(int y=0;y<linear_regressor.height();y++)
                if(linear_regressor(x,y)!=linear_regressor.no_data)
                    linear_regressor(x,y)=1/(1+pow(EULER_CONST,-linear_regressor(x,y)));

            linear_regressor.low_pass_filter();
            diagnostic("succeeded.\n");

            write_floating_data(make_fname(oname,"_lreg",do_fill,do_d8), linear_regressor);

            linear_regressor.clear();
        }
    }

    return 0;
}
